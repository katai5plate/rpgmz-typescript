/// <reference path="../../../global.d.ts" />
export default class Game_Battler extends Game_BattlerBase {
    _actions: [];
    _speed: number;
    _result: typeof Game_ActionResult;
    _actionState: unknown;
    _lastTargetIndex: unknown | number;
    _damagePopup: boolean;
    _effectType: unknown;
    _motionType: unknown;
    _weaponImageId: unknown;
    _motionRefresh: boolean;
    _selected: boolean;
    _tpbState: string;
    _tpbChargeTime: number;
    _tpbCastTime: unknown;
    _tpbIdleTime: number;
    _tpbTurnCount: number;
    _tpbTurnEnd: boolean;
    constructor(...args: any[]);
    initialize(): void;
    initMembers(): void;
    clearDamagePopup(): void;
    clearWeaponAnimation(): void;
    clearEffect(): void;
    clearMotion(): void;
    requestEffect(effectType: any): void;
    requestMotion(motionType: any): void;
    requestMotionRefresh(): void;
    cancelMotionRefresh(): void;
    select(): void;
    deselect(): void;
    isDamagePopupRequested(): boolean;
    isEffectRequested(): boolean;
    isMotionRequested(): boolean;
    isWeaponAnimationRequested(): boolean;
    isMotionRefreshRequested(): boolean;
    isSelected(): boolean;
    effectType(): unknown;
    motionType(): unknown;
    weaponImageId(): unknown;
    startDamagePopup(): void;
    shouldPopupDamage(): any;
    startWeaponAnimation(weaponImageId: any): void;
    action(index: any): never;
    setAction(index: any, action: any): void;
    numActions(): 0;
    clearActions(): void;
    result(): typeof import("./Game_ActionResult").default;
    clearResult(): void;
    clearTpbChargeTime(): void;
    applyTpbPenalty(): void;
    initTpbChargeTime(advantageous: any): void;
    tpbChargeTime(): number;
    startTpbCasting(): void;
    startTpbAction(): void;
    isTpbCharged(): boolean;
    isTpbReady(): boolean;
    isTpbTimeout(): boolean;
    updateTpb(): void;
    updateTpbChargeTime(): void;
    updateTpbCastTime(): void;
    updateTpbAutoBattle(): void;
    updateTpbIdleTime(): void;
    tpbAcceleration(): number;
    tpbRelativeSpeed(): number;
    tpbSpeed(): number;
    tpbBaseSpeed(): number;
    tpbRequiredCastTime(): number;
    onTpbCharged(): void;
    shouldDelayTpbCharge(): any;
    finishTpbCharge(): void;
    isTpbTurnEnd(): boolean;
    initTpbTurn(): void;
    startTpbTurn(): void;
    makeTpbActions(): void;
    onTpbTimeout(): void;
    turnCount(): any;
    canInput(): any;
    refresh(): void;
    addState(stateId: any): void;
    isStateAddable(stateId: any): boolean;
    isStateRestrict(stateId: any): boolean;
    onRestrict(): void;
    removeState(stateId: any): void;
    escape(): void;
    addBuff(paramId: any, turns: any): void;
    addDebuff(paramId: any, turns: any): void;
    removeBuff(paramId: any): void;
    removeBattleStates(): void;
    removeAllBuffs(): void;
    removeStatesAuto(timing: any): void;
    removeBuffsAuto(): void;
    removeStatesByDamage(): void;
    makeActionTimes(): any;
    makeActions(): void;
    speed(): number;
    makeSpeed(): void;
    currentAction(): undefined;
    removeCurrentAction(): void;
    setLastTarget(target: any): void;
    forceAction(skillId: any, targetIndex: any): void;
    useItem(item: any): void;
    consumeItem(item: any): void;
    gainHp(value: any): void;
    gainMp(value: any): void;
    gainTp(value: any): void;
    gainSilentTp(value: any): void;
    initTp(): void;
    clearTp(): void;
    chargeTpByDamage(damageRate: any): void;
    regenerateHp(): void;
    maxSlipDamage(): any;
    regenerateMp(): void;
    regenerateTp(): void;
    regenerateAll(): void;
    onBattleStart(advantageous: any): void;
    onAllActionsEnd(): void;
    onTurnEnd(): void;
    onBattleEnd(): void;
    onDamage(value: any): void;
    setActionState(actionState: any): void;
    isUndecided(): boolean;
    isInputting(): boolean;
    isWaiting(): boolean;
    isActing(): boolean;
    isChanting(): boolean;
    isGuardWaiting(): boolean;
    performActionStart(action: any): void;
    performAction(): void;
    performActionEnd(): void;
    performDamage(): void;
    performMiss(): void;
    performRecovery(): void;
    performEvasion(): void;
    performMagicEvasion(): void;
    performCounter(): void;
    performReflection(): void;
    performSubstitute(): void;
    performCollapse(): void;
}
